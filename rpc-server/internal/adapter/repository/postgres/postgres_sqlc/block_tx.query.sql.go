// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: block_tx.query.sql

package postgres_sqlc

import (
	"context"
	"time"
)

const createBlockTx = `-- name: CreateBlockTx :one
/*
    block_tx
*/

INSERT INTO block_tx(
    block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING seqno, block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time
`

type CreateBlockTxParams struct {
	BlockNumber int64
	FromAddress string
	ToAddress   string
	TxNonce     int32
	TxHash      string
	TxValue     int64
	TxGas       int64
	TxGasPrice  int64
	TxTime      time.Time
	TxData      string
	CreateTime  time.Time
}

// Create block transaction
//
//	/*
//	    block_tx
//	*/
//
//	INSERT INTO block_tx(
//	    block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
//	)
//	RETURNING seqno, block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time
func (q *Queries) CreateBlockTx(ctx context.Context, arg CreateBlockTxParams) (BlockTx, error) {
	row := q.db.QueryRow(ctx, createBlockTx,
		arg.BlockNumber,
		arg.FromAddress,
		arg.ToAddress,
		arg.TxNonce,
		arg.TxHash,
		arg.TxValue,
		arg.TxGas,
		arg.TxGasPrice,
		arg.TxTime,
		arg.TxData,
		arg.CreateTime,
	)
	var i BlockTx
	err := row.Scan(
		&i.Seqno,
		&i.BlockNumber,
		&i.FromAddress,
		&i.ToAddress,
		&i.TxNonce,
		&i.TxHash,
		&i.TxValue,
		&i.TxGas,
		&i.TxGasPrice,
		&i.TxTime,
		&i.TxData,
		&i.CreateTime,
	)
	return i, err
}

const getBlockTxByTxHash = `-- name: GetBlockTxByTxHash :one
SELECT seqno, block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time FROM block_tx
WHERE tx_hash = $1
`

// Get block transaction by tx_hash
//
//	SELECT seqno, block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time FROM block_tx
//	WHERE tx_hash = $1
func (q *Queries) GetBlockTxByTxHash(ctx context.Context, txHash string) (BlockTx, error) {
	row := q.db.QueryRow(ctx, getBlockTxByTxHash, txHash)
	var i BlockTx
	err := row.Scan(
		&i.Seqno,
		&i.BlockNumber,
		&i.FromAddress,
		&i.ToAddress,
		&i.TxNonce,
		&i.TxHash,
		&i.TxValue,
		&i.TxGas,
		&i.TxGasPrice,
		&i.TxTime,
		&i.TxData,
		&i.CreateTime,
	)
	return i, err
}

const listBlockTx = `-- name: ListBlockTx :many
SELECT seqno, block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time FROM block_tx
ORDER BY seqno DESC
LIMIT $1
`

// List block transaction
//
//	SELECT seqno, block_number, from_address, to_address, tx_nonce, tx_hash, tx_value, tx_gas, tx_gas_price, tx_time, tx_data, create_time FROM block_tx
//	ORDER BY seqno DESC
//	LIMIT $1
func (q *Queries) ListBlockTx(ctx context.Context, limit int32) ([]BlockTx, error) {
	rows, err := q.db.Query(ctx, listBlockTx, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BlockTx
	for rows.Next() {
		var i BlockTx
		if err := rows.Scan(
			&i.Seqno,
			&i.BlockNumber,
			&i.FromAddress,
			&i.ToAddress,
			&i.TxNonce,
			&i.TxHash,
			&i.TxValue,
			&i.TxGas,
			&i.TxGasPrice,
			&i.TxTime,
			&i.TxData,
			&i.CreateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
